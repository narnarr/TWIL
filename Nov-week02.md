# 왜 Docker를 사용할까?

도커를 사용하지 않을 경우 한 컴퓨터에서 사용하던 실행환경을 다른 컴퓨터에서도 동일하게 사용하고 싶을 경우 일일이 요소들을 다운받는데 또 버전 등이 동일한지도 체크해야 하는 불편함이 있다. 예를 들어 접속량이 늘어나 서버를 새로 추가해야하는데 예전에 일하던 개발자가 구축해놓은 환경을 그대로 재현해야 하는 상황 오면 현재 개발자들은 멘붕이 온다.

도커를 사용하면 어플리케이션 실행환경을 이미지로 저장해 바로 배포할 수 있다. 덕분에 서버 관리 및 서비스 배포가 굉장히 쉬워진다.

> 이미지란, 어플리케이션의 실행환경이 각종 파일들로 구성되어 있는 상태를 저장해놓은 것이다.

그리고 이 이미지를 도커 허브에서 pull 받으면 바로 컴퓨터에 설치되는 것이 아니라 컨테이너라는 독립적인 가상 공간에 설치되고 실행된다. 덕분에 한 서버에서 서로 다른 실행환경을 갖는 여러 어플리케이션을 관리하기 수월해진다.

> 컨테이너란, 이미지 위에서 실행된 특별한 프로세스다.

위의 말이 좀 추상적인데 이미지를 위해, 그리고 이미지에 의해 만들어지는 것이 컨테이너라고 생각하면 좀 편하다.

가상머신의 경우 각각이 컴퓨터의 물리적 자원을 분할해서 사용(CPU 할당)하기 때문에 성능에 한계가 생긴다. 또한 가상머신을 새로 추가할 때마다 OS도 또 설치하기 때문에 용량도 크고 속도도 느려져 성능 활용이 중요한 서버에서 비효율적이다. 반면, 도커의 컨테이너는 실행환경만 독립적으로 가질 뿐 컴퓨터 자원은 공유해서 쓰기 때문에 훨씬 빠르고 가볍게 설치가 가능하며 높은 성능을 유지할 수 있다.

# 도커 사용해보기

이미지를 추가하는 방법은 크게 세 가지가 있다.

1. pull로 미리 만들어져있는 이미지 가져오기
2. Dockerfile을 빌드하기
3. 컨테이너를 변경하여 이미지로 저장시키기 (rare)

### 01_ pull로 이미지 가져오기

얄팍한 코딩사전이라는 유튜브 채널의 "가장 쉽게 배우는 도커" 강의를 따라하였다. 페이지를 방문한 사람들이 이름을 입력하면 방명록처럼 기록이 되는 웹사이트를 만드는 강의다.

채널에서 예제로 만들어둔 프로젝트 파일을 git에서 다운받고 가장 쉬운 1번 방식으로 이미지를 추가해보았다. 

```bash
docker run -it node
```

이 코드를 터미널에 입력하면 도커허브에서 node 이미지를 다운받은 후 컨테이너로 만들어 실행하게 된다. `-it` 는 해당 컨테이너를 열고 그 환경 안에서 CLI(Command Line Interface)를 사용하겠다는 뜻이다. 즉 따로 node.js를 설치할 필요 없이 이제 내 터미널에서 자바스크립트 콘솔을 사용할 수 있게 된 것이다.

`docker images`를 입력하면 pull된 이미지 목록을 확인할 수 있고 `docker ps`를 입력하면 컨테이너 목록을 볼 수 있다.

이미지는 고정적이다. 수정하고 싶으면 삭제하고 다시 만들거나 컨테이너에 추가적인 작업을 수행하고 그 자체를 이미지로 저장해야 한다(3번 방식). `http-server`도 포함된 이미지를 새로 만들고자 방금 pull 받은 이미지를 모두 삭제한다.

```powershell
FOR /f "tokens=*" %i IN ('docker ps -q') DO docker stop %i
docker system prune -a
```

### 02_ dockerfile로 이미지 만들기

이제 2번 방식으로 이미지를 만들어 보자. 도커를 처음 배울 경우 base image를 만들어놓고 컨테이너에서 작업한 다음에 commit시키는 3번 방식이 더 쉽지 않냐는 의문이 많이 든다고 한다.(나는 아직 감도 안 잡혀서 이런 의문이 들지도 않았다)

하지만 이미지를 배포할 때 몇 기가씩이나 되는 이미지 파일 자체를 배포하기 보다 그 이미지를 만들 수 있는 스크립트인 dockerfile을 배포하는 것이 더 간편하다고 한다. 

`http-server` 를 포함한 이미지를 만들기 위한 `frontend/dockerfile` 코드는 다음과 같다.

```docker
FROM node:12.18.4

# 이미지 생성 과정에서 실행할 명령어
RUN npm install -g http-server 

# 이미지 내에서 명령어를 실행할(현 위치로 잡을) 디렉토리 설정
WORKDIR /home/node/app

# 컨테이너 실행시 실행할 명령어
CMD ["http-server", "-p", "8080", "./public"]
```

이미지를 생성하고, 컨테이너 생성 및 실행하는 명령어는 아래와 같다.

```powershell
#이미지 생성 명령어
docker build -t frontend-img . #뒤에 . 반드시 찍을 것

#컨테이너 생성 & 실행 명령어
docker run --name frontend-con -v $(pwd):/home/node/app -p 8080:8080 frontend-img
```

- `--name` : 컨테이너 이름을 설정하지 않으면 이미지 pull시 랜덤 이름이 생성되지만 어떤 용도인지 알기 쉽게 직접 이름을 설정해주면 좋다.
- `-v` : volume의 약자로, 컨테이너와 특정 폴더를 공유하는 것을 말한다.
- `$(pwd)` (윈도우의 경우 `"%cd%"` : 현재 위치 출력. 즉 현재 위치에서 만든 dockerfile을 컨테이너 내 어느 위치로 공유하면 될지 알려주는 것이다.
- `-p` : 포트. 만약 같은 이미지의 컨테이너가 두 개면 8080:8081이런 식으로 다른 포트와의 연결을 만들어주고 세 개면 또 다른 연결을 만들어줘야 한다고 한다.?? 잘 이해가 안 가요..

여튼 이런 식으로 `backend/dockerfile`와 `database/dockerfile` 도 만들 수 있지만 이 작업을 매번 반복하기 귀찮기도 하고 (이 예제의 경우에는?) 각각의 네트워크가 분리되어 있기 때문에 백엔드와 데이터베이스가 데이터를 주고받지 못한다고 한다.

이를 위해 다중 컨테이너를 한 번에 실행할 수 있는 거시적 설계도인 `docker-compose` 가 사용된다.

`docker-compse.yml` 코드:

```docker
version: '3'
services:
  database:
    # Dockerfile이 있는 위치
    build: ./database
    # 내부에서 개방할 포트 : 외부에서 접근할 포트
    ports:
      - "3306:3306"
  backend:
    build: ./backend
    # 연결할 외부 디렉토리 : 컨테이너 내 디렉토리
    volumes:
      - ./backend:/usr/src/app
    ports:
      - "5000:5000"
    # 환경변수 설정
    environment: 
      - DBHOST=database
  frontend:
    build: ./frontend
    # 연결할 외부 디렉토리 : 컨테이너 내 디렉토리
    volumes:
      - ./frontend:/home/node/app
    ports:
      - "8080:8080"
```

이제 localhost:8080을 입력하면 방명록이 정상적으로 작동하는 걸 볼 수 있다.

<궁금한 점> 

1. 하나의 포트 연결?은 한 컨테이너만 사용할 수 있는 이유가 뭔가요?
